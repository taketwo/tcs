<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>TCS: pcl::segmentation::RandomWalkerSegmentation&lt; PointT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TCS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pcl</b></li><li class="navelem"><b>segmentation</b></li><li class="navelem"><a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html">RandomWalkerSegmentation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pcl::segmentation::RandomWalkerSegmentation&lt; PointT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Multilabel semi-automatic point cloud segmentation using random walks.  
 <a href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="random__walker__segmentation_8h_source.html">random_walker_segmentation.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pcl::segmentation::RandomWalkerSegmentation&lt; PointT &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.png" usemap="#pcl::segmentation::RandomWalkerSegmentation&lt; PointT &gt;_map" alt=""/>
  <map id="pcl::segmentation::RandomWalkerSegmentation&lt; PointT &gt;_map" name="pcl::segmentation::RandomWalkerSegmentation&lt; PointT &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3392165ffa041129afb7e471e142f21e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3392165ffa041129afb7e471e142f21e"></a>
typedef PointT&#160;</td><td class="memItemRight" valign="bottom"><b>Point</b></td></tr>
<tr class="separator:a3392165ffa041129afb7e471e142f21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88191013149db8660df4b420bcf19cde"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88191013149db8660df4b420bcf19cde"></a>
typedef pcl::PointCloud&lt; Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PointCloud</b></td></tr>
<tr class="separator:a88191013149db8660df4b420bcf19cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05acfb27ebb30effa477c116f1b4fb38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05acfb27ebb30effa477c116f1b4fb38"></a>
typedef PointCloud::Ptr&#160;</td><td class="memItemRight" valign="bottom"><b>PointCloudPtr</b></td></tr>
<tr class="separator:a05acfb27ebb30effa477c116f1b4fb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d25eeae6e342764c7f38fd2526c540"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06d25eeae6e342764c7f38fd2526c540"></a>
typedef PointCloud::ConstPtr&#160;</td><td class="memItemRight" valign="bottom"><b>PointCloudConstPtr</b></td></tr>
<tr class="separator:a06d25eeae6e342764c7f38fd2526c540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69596403494f9d360d454d2f58f09569"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69596403494f9d360d454d2f58f09569"></a>
typedef boost::mpl::at<br class="typebreak"/>
&lt; PointTypeAssociations, <br class="typebreak"/>
PointT &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>PointWithNormal</b></td></tr>
<tr class="separator:a69596403494f9d360d454d2f58f09569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8b39be21d03afff11047a9ca969b63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b8b39be21d03afff11047a9ca969b63"></a>
typedef pcl::PointCloud<br class="typebreak"/>
&lt; PointWithNormal &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PointWithNormalCloud</b></td></tr>
<tr class="separator:a4b8b39be21d03afff11047a9ca969b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59120fa8c8a9ce837b719f89ab8d030a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59120fa8c8a9ce837b719f89ab8d030a"></a>
typedef PointWithNormalCloud::Ptr&#160;</td><td class="memItemRight" valign="bottom"><b>PointWithNormalCloudPtr</b></td></tr>
<tr class="separator:a59120fa8c8a9ce837b719f89ab8d030a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf84da5a13b86d6f9bdb46d0ecb7f2d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf84da5a13b86d6f9bdb46d0ecb7f2d3"></a>
typedef pcl::search::Search<br class="typebreak"/>
&lt; PointWithNormal &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Search</b></td></tr>
<tr class="separator:aaf84da5a13b86d6f9bdb46d0ecb7f2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdba8c9710a36a3f0d06f60ef9c84469"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdba8c9710a36a3f0d06f60ef9c84469"></a>
typedef Search::Ptr&#160;</td><td class="memItemRight" valign="bottom"><b>SearchPtr</b></td></tr>
<tr class="separator:abdba8c9710a36a3f0d06f60ef9c84469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57528b4f10071e8dd1344f451858fb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac57528b4f10071e8dd1344f451858fb9"></a>
typedef boost::subgraph<br class="typebreak"/>
&lt; <a class="el" href="classpcl_1_1graph_1_1point__cloud__graph.html">pcl::graph::point_cloud_graph</a><br class="typebreak"/>
&lt; PointWithNormal, boost::vecS, <br class="typebreak"/>
boost::undirectedS, <br class="typebreak"/>
boost::property<br class="typebreak"/>
&lt; boost::vertex_color_t, <br class="typebreak"/>
uint32_t &gt;, boost::property<br class="typebreak"/>
&lt; boost::edge_weight_t, float, <br class="typebreak"/>
boost::property<br class="typebreak"/>
&lt; boost::edge_index_t, int &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Graph</b></td></tr>
<tr class="separator:ac57528b4f10071e8dd1344f451858fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6211a7cb7dd66262596b574bf23ab5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a6211a7cb7dd66262596b574bf23ab5"></a>
typedef boost::graph_traits<br class="typebreak"/>
&lt; Graph &gt;::vertex_descriptor&#160;</td><td class="memItemRight" valign="bottom"><b>VertexId</b></td></tr>
<tr class="separator:a8a6211a7cb7dd66262596b574bf23ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3abcb84f832a60442e2b8678d1592f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3abcb84f832a60442e2b8678d1592f0"></a>
typedef boost::graph_traits<br class="typebreak"/>
&lt; Graph &gt;::edge_descriptor&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeId</b></td></tr>
<tr class="separator:aa3abcb84f832a60442e2b8678d1592f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87f615f78bbe86370b0389ad3f42f31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab87f615f78bbe86370b0389ad3f42f31"></a>
typedef boost::graph_traits<br class="typebreak"/>
&lt; Graph &gt;::vertex_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>VertexIterator</b></td></tr>
<tr class="separator:ab87f615f78bbe86370b0389ad3f42f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48107577d6c20c1a25a152d6ac16605"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa48107577d6c20c1a25a152d6ac16605"></a>
typedef boost::graph_traits<br class="typebreak"/>
&lt; Graph &gt;::edge_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeIterator</b></td></tr>
<tr class="separator:aa48107577d6c20c1a25a152d6ac16605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3773096b4f7c9082c2b757ebdf4d64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b3773096b4f7c9082c2b757ebdf4d64"></a>
typedef boost::graph_traits<br class="typebreak"/>
&lt; Graph &gt;::adjacency_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>AdjacencyIterator</b></td></tr>
<tr class="separator:a0b3773096b4f7c9082c2b757ebdf4d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b4a6f17386a356d29ac71a5a611ffb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1b4a6f17386a356d29ac71a5a611ffb"></a>
typedef boost::shared_ptr&lt; Graph &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GraphPtr</b></td></tr>
<tr class="separator:af1b4a6f17386a356d29ac71a5a611ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcfc879877e8432096ed4174f979986"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfcfc879877e8432096ed4174f979986"></a>
typedef boost::shared_ptr<br class="typebreak"/>
&lt; const Graph &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GraphConstPtr</b></td></tr>
<tr class="separator:acfcfc879877e8432096ed4174f979986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dde512f5f80b50e7d1f4c9813b4342b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dde512f5f80b50e7d1f4c9813b4342b"></a>
typedef <br class="typebreak"/>
boost::reference_wrapper<br class="typebreak"/>
&lt; Graph &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GraphRef</b></td></tr>
<tr class="separator:a6dde512f5f80b50e7d1f4c9813b4342b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5f6a3b1a6bca31cecc9960c778b2daec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html#a5f6a3b1a6bca31cecc9960c778b2daec">RandomWalkerSegmentation</a> (bool store_potentials=false)</td></tr>
<tr class="memdesc:a5f6a3b1a6bca31cecc9960c778b2daec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a random walker segmentation object.  <a href="#a5f6a3b1a6bca31cecc9960c778b2daec">More...</a><br/></td></tr>
<tr class="separator:a5f6a3b1a6bca31cecc9960c778b2daec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960c00e7c4d3eb65377aa3a2673b7e90"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html#a960c00e7c4d3eb65377aa3a2673b7e90">~RandomWalkerSegmentation</a> ()</td></tr>
<tr class="memdesc:a960c00e7c4d3eb65377aa3a2673b7e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a960c00e7c4d3eb65377aa3a2673b7e90">More...</a><br/></td></tr>
<tr class="separator:a960c00e7c4d3eb65377aa3a2673b7e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9cf15fc7b852478993fd726265c60a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html#aba9cf15fc7b852478993fd726265c60a">setInputCloud</a> (const PointCloudConstPtr &amp;cloud)</td></tr>
<tr class="memdesc:aba9cf15fc7b852478993fd726265c60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the input point cloud.  <a href="#aba9cf15fc7b852478993fd726265c60a">More...</a><br/></td></tr>
<tr class="separator:aba9cf15fc7b852478993fd726265c60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9809d08fa9890058682967abcf00568e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html#a9809d08fa9890058682967abcf00568e">setInputGraph</a> (const GraphPtr &amp;graph)</td></tr>
<tr class="memdesc:a9809d08fa9890058682967abcf00568e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the input point cloud graph.  <a href="#a9809d08fa9890058682967abcf00568e">More...</a><br/></td></tr>
<tr class="separator:a9809d08fa9890058682967abcf00568e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ca1e4383063f570438f684eb0d7f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html#aa6ca1e4383063f570438f684eb0d7f47">setSeeds</a> (const pcl::PointCloud&lt; PointXYZL &gt;::ConstPtr &amp;seeds)</td></tr>
<tr class="memdesc:aa6ca1e4383063f570438f684eb0d7f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a pointer to the cloud of seeds for random walker.  <a href="#aa6ca1e4383063f570438f684eb0d7f47">More...</a><br/></td></tr>
<tr class="separator:aa6ca1e4383063f570438f684eb0d7f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342cd15c3b80949e279d3f1faa6715bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html#a342cd15c3b80949e279d3f1faa6715bc">segment</a> (std::vector&lt; pcl::PointIndices &gt; &amp;clusters)</td></tr>
<tr class="memdesc:a342cd15c3b80949e279d3f1faa6715bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform random walker segmentation.  <a href="#a342cd15c3b80949e279d3f1faa6715bc">More...</a><br/></td></tr>
<tr class="separator:a342cd15c3b80949e279d3f1faa6715bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193d3d5585e9a6cb1103aaa8be5b2ece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html#a193d3d5585e9a6cb1103aaa8be5b2ece">preComputeGraph</a> ()</td></tr>
<tr class="memdesc:a193d3d5585e9a6cb1103aaa8be5b2ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a graph based on the input dataset.  <a href="#a193d3d5585e9a6cb1103aaa8be5b2ece">More...</a><br/></td></tr>
<tr class="separator:a193d3d5585e9a6cb1103aaa8be5b2ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583dc5534708d7ed717c8831913eb496"><td class="memItemLeft" align="right" valign="top">GraphConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html#a583dc5534708d7ed717c8831913eb496">getGraph</a> () const </td></tr>
<tr class="memdesc:a583dc5534708d7ed717c8831913eb496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the graph that was built (or provided with <a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html#a9809d08fa9890058682967abcf00568e" title="Provide a pointer to the input point cloud graph. ">setInputGraph()</a>) to perform random walker segmentation.  <a href="#a583dc5534708d7ed717c8831913eb496">More...</a><br/></td></tr>
<tr class="separator:a583dc5534708d7ed717c8831913eb496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b49aaec45509cb8a32412df389a9f9a"><td class="memItemLeft" align="right" valign="top">const Eigen::MatrixXf &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html#a1b49aaec45509cb8a32412df389a9f9a">getPotentials</a> () const </td></tr>
<tr class="memdesc:a1b49aaec45509cb8a32412df389a9f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vertex potentials computed during random walker segmentation.  <a href="#a1b49aaec45509cb8a32412df389a9f9a">More...</a><br/></td></tr>
<tr class="separator:a1b49aaec45509cb8a32412df389a9f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename PointT&gt;<br/>
class pcl::segmentation::RandomWalkerSegmentation&lt; PointT &gt;</h3>

<p>Multilabel semi-automatic point cloud segmentation using random walks. </p>
<p>This is based on the algorithm described in "Random Walks for Image
Segmentation" by Leo Grady. An implementation of this algorithm suitable for generic graphs (not necessarily with 3D points as vertices) is available in pcl::segmentation::randomWalks().</p>
<p>This class makes a bridge between input point cloud and the graph-based back-end algorithm. An average user only needs to supply an input point cloud and a set of seeds. The class will take care of converting the input into a weighted graph, running random walker segmentation, and interpreting its output to form point cloud clusters.</p>
<p>The default parameters that are used to construct the graph are adequate for table-top scenes captured by a 3D sensor like Kinect.</p>
<p>An advanced user may provide a pre-build graph rather than a point cloud if the defaults does not suit for the data at hand. See the tools available in the <a class="el" href="group__graph.html">pcl_graph</a> module for construction of graphs from point clouds (<a class="el" href="classpcl_1_1graph_1_1GraphBuilder.html" title="This is an abstract base class for building a BGL-compatible graph from a point cloud. ">pcl::graph::GraphBuilder</a>) and computing edge weights (<a class="el" href="structpcl_1_1graph_1_1weight_1_1weight__computer.html" title="A class that provides means to compute edge weights for a point cloud graph. ">pcl::graph::weight::weight_computer</a>).</p>
<dl class="section author"><dt>Author</dt><dd>Sergey Alexandrov </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5f6a3b1a6bca31cecc9960c778b2daec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html">pcl::segmentation::RandomWalkerSegmentation</a>&lt; PointT &gt;::<a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html">RandomWalkerSegmentation</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>store_potentials</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a random walker segmentation object. </p>
<p>Random walker segmentation has a by-product: a matrix of vertex/seed potentials. This is of no interest for a general user, however those who are actually interested in these data may access it after running segmentation with <a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html#a1b49aaec45509cb8a32412df389a9f9a" title="Get vertex potentials computed during random walker segmentation. ">getPotentials()</a>. Assembly and storage if this matrix might be expensive if the graph is big, thus this feature is disable by default and may be re-enabled on demand with the <em>store_potentials</em> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">store_potentials</td><td>controls whether the vertex potentials matrix should be assembled and stored during segmentation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a960c00e7c4d3eb65377aa3a2673b7e90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html">pcl::segmentation::RandomWalkerSegmentation</a>&lt; PointT &gt;::~<a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html">RandomWalkerSegmentation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a583dc5534708d7ed717c8831913eb496"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GraphConstPtr <a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html">pcl::segmentation::RandomWalkerSegmentation</a>&lt; PointT &gt;::getGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the graph that was built (or provided with <a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html#a9809d08fa9890058682967abcf00568e" title="Provide a pointer to the input point cloud graph. ">setInputGraph()</a>) to perform random walker segmentation. </p>

</div>
</div>
<a class="anchor" id="a1b49aaec45509cb8a32412df389a9f9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::MatrixXf&amp; <a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html">pcl::segmentation::RandomWalkerSegmentation</a>&lt; PointT &gt;::getPotentials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get vertex potentials computed during random walker segmentation. </p>
<p>This returns a const reference to a matrix of potentials formed during segmentation and stored inside this object.</p>
<dl class="section note"><dt>Note</dt><dd>Matrix assembly should be enabled during construction of the segmentation object. If it was no enabled then zero-sized matrix will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a193d3d5585e9a6cb1103aaa8be5b2ece"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html">pcl::segmentation::RandomWalkerSegmentation</a>&lt; PointT &gt;::preComputeGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a graph based on the input dataset. </p>
<p>This function constructs a graph and assigns edge weights. The user has to call this function explicitly only if he needs to access the constructed graph before running segmentation (e.g. to select seeds among graph vertices).</p>
<p>Example usage:</p>
<div class="fragment"><div class="line">RandomWalkerSegmentation&lt;PointT&gt; rws;</div>
<div class="line">rws.setInputCloud (cloud);</div>
<div class="line">rws.preComputeGraph ();</div>
<div class="line"><span class="keyword">auto</span> graph = rws.getGraph ();</div>
<div class="line"><span class="comment">// Visualize graph or graph point cloud</span></div>
<div class="line"><span class="comment">// Ask the user to select seeds</span></div>
<div class="line">rws.setSeeds (seeds);</div>
<div class="line">rws.segment (clusters);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is not necessary to call this function explicitly before performing segmentation with <a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html#a342cd15c3b80949e279d3f1faa6715bc" title="Perform random walker segmentation. ">segment()</a>! </dd></dl>

</div>
</div>
<a class="anchor" id="a342cd15c3b80949e279d3f1faa6715bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html">pcl::segmentation::RandomWalkerSegmentation</a>&lt; PointT &gt;::segment </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; pcl::PointIndices &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform random walker segmentation. </p>
<p>The clusters in the output vector will be in the order of inceasing label of their corresponding seeds.</p>
<dl class="section note"><dt>Note</dt><dd>During the segmentation the <code>vertex_color_t</code> property of the graph is modified to reflect the computed segmentation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">clusters</td><td>the resultant set of indices, indexing the points of the input cloud or input graph that correspond to the clusters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba9cf15fc7b852478993fd726265c60a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html">pcl::segmentation::RandomWalkerSegmentation</a>&lt; PointT &gt;::setInputCloud </td>
          <td>(</td>
          <td class="paramtype">const PointCloudConstPtr &amp;&#160;</td>
          <td class="paramname"><em>cloud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a pointer to the input point cloud. </p>
<p>The graph representation for the input data will be computed using the default graph builder and edge weight computer. </p>

</div>
</div>
<a class="anchor" id="a9809d08fa9890058682967abcf00568e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html">pcl::segmentation::RandomWalkerSegmentation</a>&lt; PointT &gt;::setInputGraph </td>
          <td>(</td>
          <td class="paramtype">const GraphPtr &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a pointer to the input point cloud graph. </p>

</div>
</div>
<a class="anchor" id="aa6ca1e4383063f570438f684eb0d7f47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpcl_1_1segmentation_1_1RandomWalkerSegmentation.html">pcl::segmentation::RandomWalkerSegmentation</a>&lt; PointT &gt;::setSeeds </td>
          <td>(</td>
          <td class="paramtype">const pcl::PointCloud&lt; PointXYZL &gt;::ConstPtr &amp;&#160;</td>
          <td class="paramname"><em>seeds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a pointer to the cloud of seeds for random walker. </p>
<p>A seed is a point with XYZ coordinates and a label. Seeds need not exactly coincide with any point in the input data. A kD-tree will be used to find the closest neighbor for each seed.</p>
<p>There may be multiple seeds with the same label, they will be considered to belong to the same cluster.</p>
<p>Label <code>0xFFFFFFFF</code> is not allowed! </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="random__walker__segmentation_8h_source.html">random_walker_segmentation.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 26 2014 00:47:40 for TCS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
